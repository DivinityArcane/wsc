<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>wsc documentation</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <!--<link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">-->
    <link rel="stylesheet" href="/wsc/css/main.css">
    <link rel="stylesheet" href="/wsc/css/features.css">
    <link rel="stylesheet" href="/wsc/css/docs.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
    <script type="text/javascript" src="/wsc/js/zepto.js"></script>
</head>
<body>
    <div class="squeeze">
        <nav class="menu">
            <ul>
                <li><a href="/wsc/">wsc</a></li>
                <li><a href="/wsc/damn/">wsc.dAmn</a></li>
                <li><a href="/wsc/extensions/">making extensions</a></li>
                <li><a href="/wsc/api/" class="active">api documentation</a></li>
            </ul>
        </nav>
        <nav class="contents">
    <h3>Classes</h3>
    <ul>
    
        <li><a href="/wsc/api/classes/Channel.html">Channel</a></li>
    
        <li><a href="/wsc/api/classes/Chatbook.html">Chatbook</a></li>
    
        <li><a href="/wsc/api/classes/Check.html">Check</a></li>
    
        <li><a href="/wsc/api/classes/Client.html">Client</a></li>
    
        <li><a href="/wsc/api/classes/Colour.html">Colour</a></li>
    
        <li><a href="/wsc/api/classes/Control.html">Control</a></li>
    
        <li><a href="/wsc/api/classes/dAmn.avatar.html">dAmn.avatar</a></li>
    
        <li><a href="/wsc/api/classes/dAmn.Extension.html">dAmn.Extension</a></li>
    
        <li><a href="/wsc/api/classes/Field.html">Field</a></li>
    
        <li><a href="/wsc/api/classes/Flow.html">Flow</a></li>
    
        <li><a href="/wsc/api/classes/Form.html">Form</a></li>
    
        <li><a href="/wsc/api/classes/Items.html">Items</a></li>
    
        <li><a href="/wsc/api/classes/Navigation.html">Navigation</a></li>
    
        <li><a href="/wsc/api/classes/Popup.html">Popup</a></li>
    
        <li><a href="/wsc/api/classes/Protocol.html">Protocol</a></li>
    
        <li><a href="/wsc/api/classes/Radio.html">Radio</a></li>
    
        <li><a href="/wsc/api/classes/Settings.html">Settings</a></li>
    
        <li><a href="/wsc/api/classes/Settings.Config.html">Settings.Config</a></li>
    
        <li><a href="/wsc/api/classes/Settings.Item.html">Settings.Item</a></li>
    
        <li><a href="/wsc/api/classes/Settings.Page.html">Settings.Page</a></li>
    
        <li><a href="/wsc/api/classes/SocketIO.html">SocketIO</a></li>
    
        <li><a href="/wsc/api/classes/TablumpString.html">TablumpString</a></li>
    
        <li><a href="/wsc/api/classes/template.html">template</a></li>
    
        <li><a href="/wsc/api/classes/Transport.html">Transport</a></li>
    
        <li><a href="/wsc/api/classes/UI.html">UI</a></li>
    
        <li><a href="/wsc/api/classes/WebSocket.html">WebSocket</a></li>
    
    </ul>
</nav>
        <div class="content">
            <h1 class="file-heading">File: src&#x2F;control.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Controls the input panel of the client.
 * 
 * @class Control
 * @constructor
 * @param client {Object} wsc.Client object.
 *&#x2F;
wsc.Control = function( client ) {

    this.client = client;
    this.ui = this.client.ui.control;
    this.history = {};
    this.tab = {
        hit: false,
        cache: &#x27;&#x27;,
        matched: [],
        index: -1,
        type: 0,
        prefix: [&#x27;&#x27;, &#x27;&#x2F;&#x27;, &#x27;&#x27;],
    };
    
    this.set_input();

};

&#x2F;**
 * Steal the lime light. Brings the cursor to the input panel.
 *
 * @method focus
 *&#x2F;
wsc.Control.prototype.focus = function(  ) {

    this.ui.focus();

};

&#x2F;**
 * Set the input handlers for the input panel.
 * 
 * @method set_input
 *&#x2F;
wsc.Control.prototype.set_input = function(  ) {

    var o = this;
    
    this.ui.set_handlers(
        function( event ) {
            return o.keypress(event);
        },
        function( event ) {
            return o.submit(event);
        }
    );

};

&#x2F;**
 * Save current input in a cache.
 * 
 * @method cache_input
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.cache_input = function( event ) {

    h = this.get_history( event.prev.namespace );
    
    if( h.index &gt; -1 )
        return;
    
    h.tmp = this.ui.get_text();
    this.ui.set_text(this.get_history( event.chan.namespace ).tmp);

};

&#x2F;**
 * Get a channel&#x27;s input history object.
 * If no history object exists for the given channel, a new object is created
 * and stored.
 * 
 * @method get_history
 * @param [namespace] {String} Channel to get the history of. If not given, the
 *   channel currently being viewed is used.
 * @return history {Object} Channel&#x27;s input history data.
 *&#x2F;
wsc.Control.prototype.get_history = function( namespace ) {

    if( !namespace ) {
        if( !this.client.cchannel ) {
             namespace = &#x27;~monitor&#x27;;
        }
    }
    
    namespace = namespace || this.client.cchannel.namespace;
    
    if( !this.history[namespace] )
        this.history[namespace] = { index: -1, list: [], tmp: &#x27;&#x27; };
    
    return this.history[namespace];

};

&#x2F;**
 * Append an item to the current channel&#x27;s input history.
 * 
 * @method append_history
 * @param data {String} Input string to store.
 *&#x2F;
wsc.Control.prototype.append_history = function( data ) {

    if( !data )
        return;
    
    var h = this.get_history();
    h.list.unshift(data);
    h.index = -1;
    
    if( h.list.length &gt; 100 )
        h.list.pop();

};

&#x2F;**
 * Scroll through the current channel&#x27;s input history.
 * 
 * @method scroll_history
 * @param up {Boolean} Scroll up?
 *&#x2F;
wsc.Control.prototype.scroll_history = function( up ) {

    var history = this.get_history();
    var data = this.ui.get_text();
    
    if( history.index == -1 )
        if( data )
            history.tmp = data;
    else
        history.list[history.index] = data;
    
    if( up ) {
        if( history.list.length &gt; 0 &amp;&amp; history.index &lt; (history.list.length - 1) )
            history.index++;
    } else {
        if( history.index &gt; -1)
            history.index--;
    }
    
    this.ui.set_text(history.list[history.index] || history.tmp);

};

&#x2F;**
 * Handle the tab character being pressed.
 * 
 * @method tab_item
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.tab_item = function( event ) {

    if( !this.tab.hit )
        this.start_tab(event);
    
    this.ui.chomp();
    this.tab.index++;
    
    if( this.tab.index &gt;= this.tab.matched.length )
        this.tab.index = -1;
    
    if( this.tab.index == -1 ) {
        this.ui.unchomp(this.tab.prefix[this.tab.type] + this.tab.cache);
        return;
    }
    
    suf = this.ui.get_text() == &#x27;&#x27; ? ( this.tab.type == 0 ? &#x27;: &#x27; : &#x27; &#x27; ) : &#x27;&#x27;;
    this.ui.unchomp(this.tab.prefix[this.tab.type] + this.tab.matched[this.tab.index] + suf);

};

&#x2F;**
 * Start tab complete capabilities by compiling a list of items that match the
 * current user input.
 * 
 * @method start_tab
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.start_tab = function( event ) {

    this.tab.hit = true;
    this.tab.index = -1;
    this.tab.matched = [];
    this.tab.type = 0;
    
    &#x2F;&#x2F; We only tab the last word in the input. Slice!
    var needle = this.ui.chomp();
    this.ui.unchomp(needle);
    
    &#x2F;&#x2F; Check if we&#x27;s dealing with commands here
    if( needle[0] == &quot;&#x2F;&quot; || needle[0] == &quot;#&quot; || needle[0] == &#x27;@&#x27; ) {
        this.tab.type = needle[0] == &#x27;&#x2F;&#x27; ? 1 : 2;
        if( needle[0] == &#x27;&#x2F;&#x27; )
            needle = needle.slice(1);
    } else {
        this.tab.type = 0;
    }
    
    this.tab.cache = needle;
    needle = needle.toLowerCase();
    
    &#x2F;&#x2F; Nows we have to find our matches. Fun.
    &#x2F;&#x2F; Lets start with matching users.
    this.tab.matched = [];
    if( this.tab.type == 0 ) {
        for( user in this.client.cchannel.info[&#x27;members&#x27;] )
            if( user.toLowerCase().indexOf(needle) == 0 )
                this.tab.matched.push(user);
    } else if( this.tab.type == 1 ) {
        &#x2F;&#x2F; Matching with commands.
        for( var i in this.client.cmds ) {
            cmd = this.client.cmds[i];
            if( cmd.indexOf(needle) == 0 )
                this.tab.matched.push(cmd);
        }
    } else if( this.tab.type == 2 ) {
        &#x2F;&#x2F; Matching with channels.
        var ctrl = this;
        this.client.each_channel( function( ns, chan ) {
            if( chan.namespace.toLowerCase().indexOf(needle) == 0 )
                ctrl.tab.matched.push(chan.namespace);
        } );
    }

};

&#x2F;**
 * Clear the tabbing cache.
 * 
 * @method end_tab
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.end_tab = function( event ) {

    this.tab.hit = false;
    this.tab.matched = [];
    this.tab.cache = &#x27;&#x27;;
    this.tab.index = -1;

};

&#x2F;**
 * Handle the send button being pressed.
 * 
 * @method submit
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.submit = function( event ) {

    msg = this.ui.get_text();
    this.append_history(msg);
    this.ui.set_text(&#x27;&#x27;);
    this.handle(event, msg);
    return false;

};
&#x2F;**
 * A keypress happened. Process the keypress biatch.
 * 
 * @method keypress
 * @param event {Object} Event data.
 *&#x2F;
wsc.Control.prototype.keypress = function( event ) {

    var key = event.which || event.keyCode;
    var ut = this.tab.hit;
    var bubble = false;
    
    switch( key ) {
        case 13: &#x2F;&#x2F; Enter
            if( !this.ui.multiline() ) {
                this.submit(event);
            } else {
                if( event.shiftKey ) {
                    this.submit(event);
                } else {
                    bubble = true;
                }
            }
            break;
        case 38: &#x2F;&#x2F; Up
            if( !this.ui.multiline() ) {
                this.scroll_history(true);
                break;
            }
            bubble = true;
            break;
        case 40: &#x2F;&#x2F; Down
            if( !this.ui.multiline() ) {
                this.scroll_history(false);
                break;
            }
            bubble = true;
            break;
        case 9: &#x2F;&#x2F; Tab
            if( event.shiftKey ) {
                this.client.ui.channel_right();
            } else {
                this.tab_item( event );
                ut = false;
            }
            break;
        case 219: &#x2F;&#x2F; [
            if( event.ctrlKey ) {
                this.client.ui.channel_left();
            } else {
                bubble = true;
            }
            break;
        case 221: &#x2F;&#x2F; ] (using instead of +)
            if( event.ctrlKey ) {
                this.client.ui.channel_right();
            } else {
                bubble = true;
            }
            break;
        default:
            bubble = true;
            break;
    }
    
    if( ut )
        this.end_tab( event );
    
    return bubble;

};

&#x2F;**
 * Handle some user input.
 * 
 * @method handle
 * @param event {Object} Event data.
 * @param data {String} Input message given by the user.
 *&#x2F;
wsc.Control.prototype.handle = function( event, data ) {

    if( data == &#x27;&#x27; )
        return;
    
    if( !this.client.cchannel )
        return;
    
    var autocmd = false;
    
    if( data[0] != &#x27;&#x2F;&#x27; ) {
        autocmd = true;
    }
    
    data = (event.shiftKey ? &#x27;&#x2F;npmsg &#x27; : ( data[0] == &#x27;&#x2F;&#x27; ? &#x27;&#x27; : &#x27;&#x2F;say &#x27; )) + data;
    data = data.slice(1);
    var bits = data.split(&#x27; &#x27;);
    var cmdn = bits.shift().toLowerCase();
    var ens = this.client.cchannel.namespace;
    var etarget = ens;
    
    if( !autocmd &amp;&amp; bits[0] ) {
        var hash = bits[0][0];
        if( (hash == &#x27;#&#x27; || hash == &#x27;@&#x27;) &amp;&amp; bits[0].length &gt; 1 ) {
            etarget = this.client.format_ns(bits.shift());
        }
    }
    
    var arg = bits.join(&#x27; &#x27;);
    
    var fired = this.client.trigger(&#x27;cmd.&#x27; + cmdn, {
        name: &#x27;cmd&#x27;,
        cmd: cmdn,
        args: arg,
        target: etarget,
        ns: ens
    });
    
    if( fired == 0 ) {
        this.client.ui.pager.notice({
            &#x27;ref&#x27;: &#x27;cmd-fail&#x27;,
            &#x27;heading&#x27;: &#x27;Command failed&#x27;,
            &#x27;content&#x27;: &#x27;&quot;&#x27; + cmdn + &#x27;&quot; is not a command.&#x27;
        }, false, 5000 );
    }

};



    </pre>
</div>

        </div>
    </div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
<script src="/wsc/js/docs.js"></script>
</body>
</html>
