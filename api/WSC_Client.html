<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Documentation</title>
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href='http://fonts.googleapis.com/css?family=Terminal+Dosis+Light' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../css/application.css"></link>
  </head>
  <body>
    <header id="header" class="s">
      <div class="wrapper">
        <nav>
          <h1>wsc</h1>
          
          <ul id="page-menu">
            <li>Documentation
            <li><a href="../api_index.html">Api-Docs</a>
          </ul>
          
          <form>
            <input type="search" id="search" placeholder="search API-docs" autocomplete="off" autofocus/>
          </form>
        </nav>
        
        <section class="browsers col50">          
          <section class="docs">
            <h1>Documents</h1>
            <ul>
             
               <li><a href="../docs/index.html">index</a></li>
             
            </ul>
          </section>        
          <section class="api-browser">
            <h1>API-Browser</h1>
            <ul><li class="function"><a href="wsc_client.html"><span >wsc_client</span></a><ul><li class="object"><a href="wsc_client/client.html"><span >client</span></a><ul><li class="function"><a href="wsc_client/client/init.html"><span >init</span></a></ul></ul><li class="function"><a href="wsc.html"><span >wsc</span></a></ul>
          </section>  
        </section>
        
        <section class="search-results col50">
          <section class="functions">
            <h1 class="icon function">Functions</h1>
          </section>        
          <section class="objects">
            <h1 class="icon object">Objects</h1>
          </section>
        </section> 
        
        <a href="#" class="collapse">Collapse</a>      
        <a href="#" class="expand" style="display: none;">Expand</a>         
      </div>
    </header>
    <div role="main" id="main">
      <article class="function"> 
  
  <header>
    <nav class="sidebar">
      <p>wsc/src/client.js:31</p>

      <div class="hierarchy">
        <h3>Hierarchy</h3>
        <ul><li class="this"><a href="wsc_client.html">wsc_client</a><ul class="children"><li><a href="wsc_client/client.html">client</a></li></ul></ul>
      </div>
      
      
      
      
      
      
<section class="author subsection">
  <h3 >Author</h3>
  <ul>
    <li>
  

  
    
    
    <p>photofroggy</p>

  
  
</li>  
  </ul>
</section>

    </nav>
  
    <h1>wsc_client</h1>
    <section class="notification">
      
<section class="note subsection">
  <h3 >Note</h3>
  <ul>
    <li>
  

  
    
    
    <p>To create a client, use the <a href="wsc.html">wsc jQuery method</a>.</p>

  
  
</li>  
  </ul>
</section>

    </section> 
  </header>
    
  <div class="body">
    
    <p>wsc_client is a constructor for the <a href="wsc_client/client.html">wsc client</a> object.</p>

    
    <!--span class="flag">constructor</span-->
   
    
    
    
    
    
      <h2 class="signature">(Object) <span class='name'>wsc_client</span>(<span class='params'><span class="param">element</span><span class="tooltip">(<span class="types">jQuery</span>) Main view for the client to be drawn in.
</span>, <span class="param">options</span><span class="tooltip">(<span class="types"></span>) Here the client's settings can be defined, and we store them in ``client.settings``. The settings available are as follows:</span>, <span class="param">mozilla</span><span class="tooltip">(<span class="types">Boolean</span>) Is the browser being used made by mozilla?
</span></span>)</h2>
      
<section class="param subsection">
  <h3 >Param</h3>
  <ul>
    <li>
  
    <h4>element</h4>
  

  
    
    
      (<span class="types">jQuery</span>)
    
    <p>Main view for the client to be drawn in.</p>

  
  
</li>  
<li>
  
    <h4>options</h4>
  

  
    <p>Here the client's settings can be defined, and we store them in <code>client.settings</code>. The settings available are as follows:</p>

    <ul>
      <li>
  
    <h4>domain</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>The domain of the website hosting the client. Used for constructing URLs.</p>

  
  
</li>  
<li>
  
    <h4>server</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>Address for the WebSocket server to connect to.</p>

  
  
</li>  
<li>
  
    <h4>agent</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>The client's user-agent. This is sent in the handshake when connecting to the chat server.</p>

  
  
</li>  
<li>
  
    <h4>username</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>Name of the user using the client.</p>

  
  
</li>  
<li>
  
    <h4>symbol</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>User symbol for the user. This is automatically updated when the client logs in to the chat server.</p>

  
  
</li>  
<li>
  
    <h4>pk</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>The user's chat token. Required for logging in to the chat server.</p>

  
  
</li>  
<li>
  
    <h4>monitor</h4>
  

  
    
    
      (<span class="types">Array</span>)
    
    <p>Configuration for the monitor channel. <code>[(String) shorthand_name, (Bool) hidden]</code>.</p>

  
  
</li>  
<li>
  
    <h4>welcome</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>Define the message displayed when the client is loaded.</p>

  
  
</li>  
<li>
  
    <h4>autojoin</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>Define the channel to join when the client logs in successfully.</p>

  
  
</li>  
<li>
  
    <h4>protocol</h4>
  

  
    
    
      (<span class="types">Function</span>)
    
    <p>A function which returns a protocol parser. By default, wsc_protocol is used.</p>

  
  
</li>  
<li>
  
    <h4>extend</h4>
  

  
    
    
      (<span class="types">Array</span>)
    
    <p>Array of extensions. By default, this only includes wsc_extdefault. Refer to wsc_extbase for more information.</p>

  
  
</li>  
<li>
  
    <h4>client</h4>
  

  
    
    
      (<span class="types">String</span>)
    
    <p>Client string to send in the handshake. Defaults to <code>chatclient</code>.</p>

  
  
</li>  
<li>
  
    <h4>tablumps</h4>
  

  
    
    
      (<span class="types">Function</span>)
    
    <p>Tablumps parser constructor. By default, wsc_tablumps is used.</p>

  
  
</li>  
    </ul>  
    
  
</li>  
<li>
  
    <h4>mozilla</h4>
  

  
    
    
      (<span class="types">Boolean</span>)
    
    <p>Is the browser being used made by mozilla?</p>

  
  
</li>  
  </ul>
</section>

      
<section class="return subsection">
  <h3 >Return</h3>
  <ul>
    <li>
  

  
    
    
      (<span class="types">Object</span>)
    
    <p>A <a href="wsc_client/client.html">wsc client</a> object.</p>

  
  
</li>  
  </ul>
</section>


    
    
    <h3 class="source">Source</h3>
    <code class="source brush:js first-line:31">function wsc_client( view, options, mozilla ) {
    
    /**
     * @object client
     * @author photofroggy
     * 
     * @note To create a client, use the {wsc wsc jQuery method}.
     * 
     * This object acts as a client for dAmn-like chat servers.
     * When initialising the object, you can provide different configuration
     * options using the ``options`` parameter.
     */
    var client = {
    
        view: null,
        mozilla: false,
        control: null,
        tabul: null,
        chatbook: null,
        connected: false,
        conn: null,
        evt_chains: [[&quot;recv&quot;, &quot;admin&quot;]],
        events: null,
        settings: {
            &quot;domain&quot;: &quot;website.com&quot;,
            &quot;server&quot;: &quot;ws://website.com/wsendpoint&quot;,
            &quot;agent&quot;: &quot;wsc 0.1a&quot;,
            &quot;symbol&quot;: &quot;&quot;,
            &quot;username&quot;: &quot;&quot;,
            &quot;userinfo&quot;: {},
            &quot;pk&quot;: &quot;&quot;,
            // Monitor: `ns`
            &quot;monitor&quot;: ['~Monitor', true],
            &quot;welcome&quot;: &quot;Welcome to the wsc web client!&quot;,
            &quot;autojoin&quot;: &quot;chat:channel&quot;,
            &quot;protocol&quot;: wsc_protocol,
            &quot;extend&quot;: [wsc_extdefault],
            &quot;control&quot;: wsc_control,
            &quot;stype&quot;: 'llama',
            &quot;client&quot;: 'chatclient',
            &quot;tablumps&quot;: wsc_tablumps,
            &quot;avatarfile&quot;: '$un[0]/$un[1]/{un}.png',
            &quot;defaultavatar&quot;: 'default.gif',
            &quot;avatarfolder&quot;: '/avatars/',
            &quot;emotefolder&quot;: '/emoticons/',
            &quot;thumbfolder&quot;: '/thumbs/',
        },
        // Protocol object.
        protocol: null,
        // Object containing all channel objects.
        channelo: {},
        // Current channel object.
        cchannel: null,
        // Known command names.
        cmds: [],
        
        /**
         * @constructor init
         * @author photofroggy
         * 
         * I guess this is what I would consider the &quot;actual&quot; constructor.
         * 
         * @param [jQuery] element The client's main view.
         * @param [Boolean] mozilla Are we running firefox?
         */
        init: function( view, options, mozilla ) {
            
            view.append('&lt;div class=&quot;wsc&quot;&gt;&lt;/div&gt;');
            // Set up variables.
            this.view = view.find('.wsc');
            this.mozilla = mozilla;
            this.connected = false;
            this.conn = null;
            this.events = new EventEmitter();
            this.view.extend( this.settings, options );
            this.mns = this.format_ns(this.settings['monitor'][0]);
            this.lun = this.settings[&quot;username&quot;].toLowerCase();
            this.channelo = {};
            this.protocol = this.settings[&quot;protocol&quot;]( this );
            //this.addListener('closed'
            
            // Debug!
            //console.log(this);
            
            // Load in extensions
            this.cmds = [];
            for(var index in this.settings[&quot;extend&quot;]) {
                ext = this.settings[&quot;extend&quot;][index](this);
                if( !ext )
                    continue;
                ext.register();
            }
            
            // Prepare the UI.
            this.buildUI();
            
            // Welcome!
            this.monitor(this.settings[&quot;welcome&quot;]);
            
        },
        
        // Register a listener with an event.
        addListener: function( event, handler ) {
            this.events.addListener(event, function( e ) { handler( e ); });
            jqi = event.indexOf('.wsc');
            
            if( event.indexOf('cmd.') != 0 || jqi == -1 || jqi == 4 )
                return;
            
            cmd = event.slice(4, jqi).toLowerCase();
            this.cmds.push(cmd);
        },
        
        // Remove listeners.
        removeListeners: function( ) {
            this.events.removeListeners();
        },
        
        // Run events dawg.
        trigger: function( event, data ) {
            //console.log(&quot;emitting &quot;+ event);
            this.events.emit(event, data);
        },
        
        // Channel method wooo
        channel: function( namespace, chan ) {
            namespace = this.deform_ns(namespace).slice(1).toLowerCase();
            /* 
            console.log(namespace);
            console.log(this.channelo);
            /* */
            if( !this.channelo[namespace] &amp;&amp; chan )
                this.channelo[namespace] = chan;
            
            return this.channelo[namespace];
        },
        
        // How many channels are we joined in?
        channels: function( ) {
            // - 2 because we always has at least 2 tabs open. Change for release.
            chans = -1;
            for(ns in client.channelo) {
                if( client.channelo[ns].hidden )
                    continue;
                chans++;
            }
            return chans;
        },
        
        // Start the client.
        connect: function( ) {
            if( client.connected )
                return;
            // Start connecting!
            if(CanCreateWebsocket()) {
                client.conn = client.createChatSocket();
                //console.log(&quot;connecting&quot;);
                client.trigger({name: 'start.wsc', pkt: wsc_packet('client connecting\ne=ok\n\n')});
            } else {
                client.monitor(&quot;Your browser does not support WebSockets. Sorry.&quot;);
                client.trigger({name: 'start.wsc', pkt: wsc_packet('client connecting\ne=no websockets available\n\n')});
            }
        },
        
        // Create a new WebSocket chat connection.
        createChatSocket: function( ) {
            
            var client = this;
            return CreateWebSocket(
                this.settings[&quot;server&quot;],
                // WebSocket connection closed!
                function( evt ) { client.protocol.closed( evt ); },
                // Received a message from the server! Process!
                function( evt ) { client.protocol.process_data( evt ); },
                // Connection opened.
                function( evt ) { client.protocol.connected( evt ); }
            );
            
        },
        
        // Build the initial UI.
        buildUI: function( ) {
            this.view.append( wsc_html_ui );
            this.control = this.settings['control']( this );
            this.tabul = this.view.find('#chattabs');
            this.chatbook = this.view.find('div.chatbook');
            // The monitor channel is essentially our console for the chat.
            hide = this.settings.monitor[1];
            this.createChannel(this.mns, hide);
            this.control.setInput();
            this.control.focus();
            /*
            this.cchannel.setHeader('title', { pkt: {
                        &quot;arg&quot;: { &quot;by&quot;: &quot;&quot;, &quot;ts&quot;: &quot;&quot; },
                        &quot;body&quot;: '&lt;p&gt;sample title&lt;/p&gt;'
                    }
                }
            );
            /**/
            /*
            this.cchannel.setHeader('topic', { pkt: {
                        'arg': { 'by': '', 'ts': '' },
                        'body': '&lt;p&gt;sample topic&lt;/p&gt;'
                    }
                }
            );
            /**/
            // For testing purposes only.
            // this.createChannel(&quot;llama2&quot;, &quot;~Llama2&quot;, &quot;server:llama2&quot;);
            this.resizeUI();
        },
        
        resizeUI: function( ) {
            // Resize control panel.
            client.control.resize();
            
            
            // Main view dimensions.
            client.view.height( client.view.parent().height() );
            client.view.width( '100%' );
            
            h = (client.view.parent().height() - client.tabul.outerHeight(true) - client.control.height());
            //console.log('&gt;&gt;',client.view.parent().innerHeight(),client.tabul.outerHeight(true),client.control.height())
            // Chatbook dimensions.
            client.chatbook.height(h);
            
            // Channel dimensions.
            for(select in client.channelo) {
                chan = client.channel(select);
                chan.resize();
            }
            //client.control.resize();
        },
        
        // Create a screen for channel `ns` in the UI, and initialise data
        // structures or some shit idk. The `selector` parameter defines the
        // channel without the `chat:` or `#` style prefixes. The `ns`
        // parameter is the string to use for the tab.
        createChannel: function( ns, toggle ) {
            chan = this.channel(ns, wsc_channel(this, ns), toggle);
            chan.build();
            this.toggleChannel(ns);
            if( toggle )
                chan.invisible();
        },
        
        // Remove a channel from the client and the GUI.
        // We do this when we leave a channel for any reason.
        // Note: last channel is never removed and when removing a channel
        // we switch to the last channel in the list before doing so.
        removeChannel: function( ns ) {
            if( this.channels() == 0 ) 
                return;
            
            chan = this.channel(ns);
            chan.remove();
            delete this.channelo[chan.info[&quot;selector&quot;]];
            
            var select = '';
            for (tmp in this.channelo) {
                if (this.channelo.hasOwnProperty(tmp) &amp;&amp; tmp != chan.info['selector'])
                    select = tmp;
            }
            
            this.toggleChannel(select);
            this.channel(select).resize();
        },
        
        // Select which channel is currently being viewed.
        toggleChannel: function( ns ) {
            //console.log(&quot;out: &quot;+previous+&quot;; in: &quot;+ns);
            chan = this.channel(ns);
            
            if( !chan )
                return;
            
            if(this.cchannel) {
                if(this.cchannel == chan)
                    return;
                // Hide previous channel, if any.
                //console.log(&quot;prevshift &quot;, previous);
                this.cchannel.hideChannel();
                this.control.cacheInput();
            }
            
            // Show clicked channel.
            chan.showChannel();
            this.control.focus();
            this.cchannel = chan;
            this.control.setLabel();
            if( this.settings['monitor'][1] ) {
                mt = this.tabul.find('#' + this.channel(this.mns).info['selector'] + '-tab')
                mt.addClass(this.settings['monitor'][1]);
            }
            this.resizeUI();
        },
    
        // Write a message to the UI.
        // `ns` is the name of the channel. No `chat:` or `#` style prefix.
        // `msg` is the raw string to be desplayed. Provide messages fully
        // formatted in HTML kthxbai.
        log: function( ns, msg ) {
            var chan = this.channel(ns);
            if( !chan )
                return;
            chan.log(msg);
        },
        
        // Send a log message to all channels.
        logAll: function( msg ) {
            for( ns in this.channelo )
                this.channlo[ns].log(msg);
        },
        
        // Send a log item to all channels.
        logItemAll: function( msg ) {
            for( ns in this.channelo )
                this.channelo[ns].logItem(msg);
        },
        
        monitorAll: function( msg, info ) {
            for( ns in this.channelo )
                this.channelo[ns].serverMessage(msg, info);
        },
        
        // Write a server message to the UI.
        serverMessage: function( ns, msg, info ) {
            var chan = this.channel(ns);
            if( !chan )
                return;
            chan.serverMessage(msg, info);
        },
        
        // System message displayed in the monitor window.
        monitor: function( msg, info ) {
            this.serverMessage(this.mns, msg, info);
        },
        
        // Deform a channel namespace.
        deform_ns: function( ns ) {
            if(ns.indexOf(&quot;chat:&quot;) == 0)
                return '#' + ns.slice(5);
            
            if(ns.indexOf(&quot;server:&quot;) == 0)
                return '~' + ns.slice(7);
            
            if(ns.indexOf(&quot;pchat:&quot;) == 0) {
                var names = ns.split(&quot;:&quot;);
                names.shift();
                for(var name in names) {
                    if(name.toLowerCase() != this.lun) {
                        return '@' + name;
                    }
                }
            }
            
            if(ns[0] != '#' &amp;&amp; ns[0] != '@' &amp;&amp; ns[0] != '~')
                return '#' + ns;
            
            return ns;
        },
        
        // Format a channel namespace.
        format_ns: function( ns ) {
            if(ns.indexOf('#') == 0) {
                return 'chat:' + ns.slice(1);
            }
            if(ns.indexOf('@') == 0) {
                var names = [ns.slice(1), this.lun];
                names.sort(caseInsensitiveSort)
                names.unshift(&quot;pchat&quot;);
                return names.join(':');
            }
            if(ns.indexOf('~') == 0) {
                return &quot;server:&quot; + ns.slice(1);
            }
            if(ns.indexOf('chat:') != 0 &amp;&amp; ns.indexOf('server:') != 0 &amp;&amp; ns.indexOf('pchat:') != 0)
                return 'chat:' + ns;
            
            return ns;
        },
        
        // Get the event name of a given packet.
        event_name: function( pkt ) {
            
            var name = pkt[&quot;cmd&quot;];
            var cmds = null;
            for(var index in this.evt_chains) {
                
                cmds = this.evt_chains[index];
                
                if(cmds[0] != name)
                    continue;
                
                var sub = wsc_packet(pkt[&quot;body&quot;]);
                name = name + '_' + sub[&quot;cmd&quot;];
                
                if(cmds.length &gt; 1 &amp;&amp; sub[&quot;param&quot;] != undefined) {
                    if(cmds[1] == sub[&quot;cmd&quot;])
                        return name + '_' + sub[&quot;param&quot;];
                }
            
            }
            
            return name;
        },
        
        // Send a message to the server.
        // Uses a raw packet string.
        send: function( msg ) {
            if(this.connected) {
                return this.conn.send(msg);
            }
            return -1;
        },
        
        // Protocol methods. Woop!
        
        // Send the chat user agent.
        handshake: function( ) {
            this.send(wsc_packetstr(this.settings['client'], &quot;0.3&quot;, {
                &quot;agent&quot;: this.settings[&quot;agent&quot;]
            }));
        },
        
        // Send a pong!
        pong: function( ) {
            this.send(wsc_packetstr(&quot;pong&quot;));
        },
        
        // Send login details.
        login: function( ) {
            pkt = 'login ' + this.settings[&quot;username&quot;] + '\npk=' + this.settings[&quot;pk&quot;] + '\n';
            this.send( pkt );
        },
        
        // Join a channel.
        join: function( ns ) {
            this.send(wsc_packetstr(&quot;join&quot;, this.format_ns(ns)));
        },
        
        // Part a channel.
        part: function( ns ) {
            this.send(wsc_packetstr('part', this.format_ns(ns)));
        },
        
        // Promote a user.
        promote: function( ns, user, pc ) {
            this.send(wsc_packetstr('send', this.format_ns(ns), {},
                wsc_packetstr('promote', user, {}, ( !pc ? '' : pc ))));
        },
        
        // Send a message to a channel.
        say: function( ns, msg ) {
            this.send(wsc_packetstr('send', this.format_ns(ns), {},
                wsc_packetstr('msg', 'main', {}, msg)
            ));
        },
        
        // Send a non-parsed message to a channel.
        npmsg: function( ns, msg ) {
            this.send(wsc_packetstr('send', this.format_ns(ns), {},
                wsc_packetstr('npmsg', 'main', {}, msg)
            ));
        },
        
        // Send an action message to a channel.
        action: function( ns, action ) {
            this.send(wsc_packetstr('send', this.format_ns(ns), {},
                wsc_packetstr('action', 'main', {}, action)
            ));
        },
        
        // Set the title.
        title: function( ns, title ) {
            this.send(wsc_packetstr('set', this.format_ns(ns), {
                'p': 'title'}, title));
        },
        
        // Kick some mofo
        kick: function( ns, user, r ) {
            this.send(wsc_packetstr('kick', this.format_ns(ns), {
                'u': user }, r ? r : null));
        },
    
    };
    
    client.init(view, options, mozilla);
    return client;

}
</code>
  
  </div>
 
</article> 
    </div>
    <footer id="footer">
      <div class="wrapper">
        Documentation created automagically with <a href="http://www.github.com/b-studios/doc.js">Doc.js for ruby</a>.
      </div>
    </footer>
    <script src="../js/jcore.js"></script>    
    <script>
      var J = J || {};
      J.root = "../";
      window.jQuery || document.write("<script src='"+J.root+"js/jquery.js'>\x3C/script>")
    </script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6/jquery.js"></script>
    <script src="../js/jquery.treeview.js"></script><script src="../js/jquery.cookie.js"></script><script src="../js/jquery.tooltip.js"></script><script src="../js/regexpx.js"></script><script src="../js/shCore.js"></script><script src="../js/shBrushJScript.js"></script><script src="../js/application.js"></script><script src="../js/apisearch-data.js"></script>
  <body>
</html>
